
colors:
  marginalCost: colors.red
  averageCost: colors.purple
  totalCost: colors.red

params:
  - name: a
    value: 0.5
    min: 0.1
    max: 0.75
    round: 0.05
  - name: p11
    value: 1
    min: 0.4
    max: 3
    round: 0.1
  - name: p12
    value: 2
    min: 0.3
    max: 3
    round: 0.1
  - name: p2
    value: 2
  - name: m
    value: 20

calcs:
  c: params.m * ((params.p12/params.p11)^(params.a))
  p: params.p12/params.p11
aspectRatio: 0.8

layout:
  TwoVerticalGraphsPlusSidebar:

    topGraph:
      yAxis:
        title: Unità di Bene 2
        max: 15
        min: 0
        ticks: 0
      xAxis:
        title: Unità di Bene 1
        max: 32
        min: 0
        ticks: 0
      objects:

        # Original indifference curve
        - EconIndifferenceCurve:
            utilityFunction:
              CobbDouglas: {alpha: (params.a)}
            level: params.m * ((params.a/params.p11)^(params.a)) * (((1-params.a)/(params.p2))^(1-params.a))
            color: Black
            label: dd
            strokeWidth: 1

        # New indifference curve
        - EconIndifferenceCurve:
            utilityFunction:
              CobbDouglas: {alpha: (params.a)}
            level: params.m * ((params.a/params.p12)^(params.a)) * (((1-params.a)/(params.p2))^(1-params.a))
            color: Black
            label: dd
            strokeWidth: 1

        # Original budget line
        - Line:
            slope: -(params.p11)/(params.p2)
            point: [0,(params.m)/(params.p2)]
            color: Green
            label:
              text:
              x: 33
              position: tl
            strokeWidth: 1.5

        # New budget line
        - Line:
            slope: -(params.p12)/(params.p2)
            point: [0,(params.m)/(params.p2)]
            color: Green
            label:
              text:
              x: 33
              position: tl
            strokeWidth: 1.5

        # Compensated budget line
        - Line:
            slope: -(params.p12)/(params.p2)
            point: [0,(calcs.c)/(params.p2)]
            color: Red
            label:
              text:
              x: 33
              position: tl
            strokeWidth: 0.75

        # Original optimum
        - Point:
            coordinates: [(params.a)*(params.m)/(params.p11),(1-(params.a))*(params.m)/(params.p2)]
            droplines:
              vertical: math.round((params.a)*(params.m)/(params.p11), 1)
              horizontal: math.round((1-(params.a))*(params.m)/(params.p2), 1)
            color: Blue

        # New optimum
        - Point:
            coordinates: [params.a*params.m/params.p12,(1-(params.a))*(params.m)/(params.p2)]
            droplines:
              vertical: math.round((params.a)*(params.m)/(params.p12), 1)
              horizontal: math.round((1-(params.a))*(params.m)/(params.p2), 1)
            color: Blue

        # Compensated optimum
        - Point:
            coordinates: [params.a*calcs.c/params.p12,(1-(params.a))*(calcs.c)/(params.p2)]
            droplines:
              vertical: math.round((params.a)*(calcs.c)/(params.p12), 1)
              horizontal: math.round((1-(params.a))*(calcs.c)/(params.p2), 1)
            color: Purple

    bottomGraph:
      yAxis:
        title: Euro
        max: 3.2
        ticks: 0
      xAxis:
        title: Unità di Bene 1
        max: 32
        ticks: 0
      objects:

        # Walrasian demand function
        - Curve:
            fn: params.a * params.m / (x)
            color: Blue
            label:
              text: \large x_1
              x: 28
              position: bl
              bgcolor: none
            strokeWidth: 1.5
            max: 

        # Hicksian demand function
        - Curve:
            fn: (( params.a * params.m ) / ( (x) * ((params.p11)^params.a) ))^(1/(1-params.a))
            color: Purple
            label:
              text: \large x^c_1
              x: (params.a)*(params.m * ((3/params.p11)^(params.a)))/3
              position: tl
              bgcolor: none
            strokeWidth: 1.5

        # Original optimum
        - Point:
            coordinates: [params.a*params.m/params.p11,params.p11]
            droplines:
              vertical: math.round((params.a)*(params.m)/(params.p11), 1)
              horizontal: math.round(params.p11, 1)
            color: Blue

        # New optimum
        - Point:
            coordinates: [params.a*params.m/params.p12,params.p12]
            droplines:
              vertical: math.round((params.a)*(params.m)/(params.p12), 1)
              horizontal: math.round(params.p12, 1)
            color: Blue

        # Compensated optimum
        - Point:
            coordinates: [params.a*calcs.c/params.p12,params.p12]
            droplines:
              vertical: math.round((params.a)*(calcs.c)/(params.p12), 1)
              horizontal:
            color: Purple

        # Negative variation in CS when price increases
        - Area:
            fn1: min(params.p12,((params.a*params.m)/((x)*((params.p11)^params.a)))^(1/(1-params.a)),(params.a*params.m)/(x))
            fn2: min(params.p11,params.p12)
            fill: Red
            opacity: 0.3
            min: 0
            max: max(params.a*params.m/params.p11,params.a*calcs.c/params.p12)

        # Difference between CV and DeltaCS when price increases
        - Area:
            fn1: min(params.p12,((params.a*params.m)/((x)*((params.p11)^params.a)))^(1/(1-params.a)))
            fn2: min((params.a*params.m)/(x),params.p12)
            fill: Purple
            opacity: 0.3
            min: 0
            max: max(params.a*params.m/params.p11,params.a*calcs.c/params.p12)

        # Positive variation in CS when price decreases
        - Area:
            fn1: min(params.p11,((params.a*params.m)/((x)*((params.p11)^params.a)))^(1/(1-params.a)))
            fn2: min(params.p11,params.p12)
            fill: Green
            min: 0
            max: max(params.a*params.m/params.p11,params.a*calcs.c/params.p12)

        # Difference between CV and DeltaCS when price increases
        - Area:
            fn1: min(params.p11,(params.a*params.m)/(x))
            fn2: min(params.p11,max((params.p12),((params.a*params.m)/((x)*((params.p11)^params.a)))^(1/(1-params.a))))
            fill: Blue
            opacity: 0.2
            min: 0
            max: params.a*params.m/params.p12


    sidebar:
      controls:
      - title: From individual ITA demand to market demand
        description:
        sliders:
        - param: a
          label: \alpha_1
        - param: p11
          label: P_1
        - param: p12
          label: P'_1
        divs:
          - html: $N$ consumers with demand $$x(P)=\frac{\alpha M}{P_X}$$
            show: params.p11 == 1

    explanation:
      divs:
        - html: "`When $P = ${params.p11.toFixed(1)}$, the consumer sets $MB= P$ at $Q = ${calcs.c.toFixed(1)}$ and the firm sets $P = MC$ at $Q = ${calcs.c.toFixed(1)}$.`"
        - html: "`If we assume the total amount produced and consumed must be the smaller of those two, then the amount in the market is $Q = ${calcs.c.toFixed(2)}$. At that quantity, $MB > MC$, so total surplus could be increased if $Q$ were higher.`"
          show: params.p11 != 1
        - html: Since the amount the firm makes is the amount the consumer wants to consume, the market would be in competitive equilibrium. If you move the price up and down, you can see that the total surplus at the equilibrium price is higher than at any other price.
          show: params.p11 == 1
